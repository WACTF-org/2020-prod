package main

import (
	"crypto/rand"
	"encoding/gob"
	"fmt"
	"io"
	"net"
	"os"
	"pkg"
)

func main() {
	fmt.Println("Listening on 31337(?)")
	doNetworking()
}

func handleConnection(conn net.Conn) {
	defer conn.Close()
	dec := gob.NewDecoder(conn)
	enc := gob.NewEncoder(conn)

	loginMsg := pkg.LoginMsg{}
	err := dec.Decode(&loginMsg)
	if err != nil {
		return
	}
	good := false
	if loginMsg.Username == "admin" && loginMsg.Password == "AnotherYear?" {
		good = true
	}
	randybois := make([]byte, 16)
	rand.Read(randybois)
	loginRsp := pkg.LoginResult{
		Success:           good,
		VeryImportantData: randybois,
	}
	enc.Encode(&loginRsp)

	postLogin := pkg.PostLoginMsg{}
	err = dec.Decode(&postLogin)
	if err != nil {
		return
	}

	postrsp := pkg.PostLoginRsp{
		MoreNormalWords:   pkg.GetWords(),
		Mac11s:            7,
		ThirtyEights:      8,
		Nines:             9,
		Mac10s:            10,
		JustIgnoreThisBit: fmt.Sprintf("WACTF{%s_%s}", flag, flagsuff),
		JoinYourUnion:     pkg.GetWords(),
	}
	enc.Encode(&postrsp)
}

var flag, flagexists = os.LookupEnv("WACTF_FLAG")
var flagsuff, flagsuffexists = os.LookupEnv("WACTF_FLAG_SUFFIX")

func doNetworking() {
	ln, err := net.Listen("tcp", ":31337")

	if err != nil && err != io.EOF {
		panic("Could not bind to address:" + err.Error())
	}

	for {
		conn, err := ln.Accept()
		if err != nil {
			continue
		}
		fmt.Println("Debug: Connection " + conn.RemoteAddr().String())
		go handleConnection(conn)
	}
}
